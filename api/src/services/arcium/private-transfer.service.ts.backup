import { Connection, PublicKey, Keypair, SystemProgram, Transaction, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { Program, AnchorProvider, Wallet } from '@coral-xyz/anchor';
import BN from 'bn.js';
import { RescueCipher, x25519 } from '@arcium-hq/client';
import { randomBytes } from 'crypto';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// ES Module compatibility
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration Arcium
const PROGRAM_ID = new PublicKey('Ht7b6ihDZy3Fu8b9HfwL9gr9LiRfoPrCap4kzqvwvJLC'); // âœ… Nouveau program ID deployed
const ARCIUM_PROGRAM_ID = new PublicKey('BKck65TgoKRokMjQM3datB9oRwJ8rAj2jxPXvHXUvcL6');
const RPC_ENDPOINT = 'https://devnet.helius-rpc.com/?api-key=1fd9c16e-ba78-4e69-917a-ac211500c452';
// âš ï¸ MXE_ACCOUNT Ã  recrÃ©er pour nouveau programme! Utiliser: arcium init-mxe --callback-program Ht7b6ihDZy3Fu8b9HfwL9gr9LiRfoPrCap4kzqvwvJLC
const MXE_ACCOUNT = new PublicKey('2BSzBG1ykGs2pdYmhY5M4ZuDSyPfaab7tKjqkshsy5po');

interface RegisterUserResult {
  success: boolean;
  userId?: number;
  balancePDA?: string;
  signature?: string;
  error?: string;
}

interface PrivateTransferResult {
  success: boolean;
  signature?: string;
  computationOffset?: string;
  error?: string;
}

interface BalanceInfo {
  userId: number;
  encryptedBalance: number[];
  nonce: string;
}

interface ExecutePrivateTransferFromUserResult {
  success: boolean;
  signature?: string;
  senderWallet?: string;
  recipientWallet?: string;
  arciumUserId?: number;
  arciumBalancePDA?: string;
  error?: string;
}

/**
 * Service pour gÃ©rer les transactions privÃ©es avec Arcium MPC
 *
 * Architecture:
 * 1. Chaque utilisateur reÃ§oit un ID unique (u32)
 * 2. Les balances sont stockÃ©es chiffrÃ©es on-chain
 * 3. Les transferts utilisent le MPC cluster pour valider et calculer
 * 4. Privacy 100%: montants et balances jamais rÃ©vÃ©lÃ©s
 */
class PrivateTransferService {
  private connection: Connection;
  private program: Program | null = null;
  private provider: AnchorProvider | null = null;
  private mxePublicKey: Uint8Array | null = null;

  constructor() {
    this.connection = new Connection(RPC_ENDPOINT, 'confirmed');
    this.loadProgram();
  }

  /**
   * Convertit l'IDL Arcium au format Anchor v0.29 compatible
   */
  private convertArciumIdlToAnchor(arciumIdl: any): any {
    // Convertir les types avec le nouveau format vers l'ancien
    const convertType = (type: any): any => {
      if (!type) return type;

      // Si c'est un objet avec "defined", le convertir
      if (type.defined && typeof type.defined === 'object' && type.defined.name) {
        return type.defined.name;
      }

      return type;
    };

    // Convertir rÃ©cursivement tous les champs de types
    const convertTypes = (types: any[]): any[] => {
      if (!types || !Array.isArray(types)) return [];

      return types.map(typeObj => {
        if (typeObj.type?.kind === 'struct' && typeObj.type.fields) {
          return {
            ...typeObj,
            type: {
              ...typeObj.type,
              fields: typeObj.type.fields.map((field: any) => ({
                ...field,
                type: convertType(field.type)
              }))
            }
          };
        }
        return typeObj;
      });
    };

    // Anchor v0.29 attend metadata.address, pas address au niveau racine
    const converted = {
      version: arciumIdl.metadata?.version || '0.1.0',
      name: arciumIdl.metadata?.name || 'private_transfer',
      instructions: arciumIdl.instructions || [],
      accounts: arciumIdl.accounts || [],
      types: convertTypes(arciumIdl.types),
      events: arciumIdl.events || [],
      errors: arciumIdl.errors || [],
      metadata: {
        address: arciumIdl.address,
        ...arciumIdl.metadata
      }
    };

    return converted;
  }

  /**
   * Charge le programme Anchor avec l'IDL
   */
  private async loadProgram(): Promise<void> {
    try {
      // Charger l'IDL du programme dÃ©ployÃ©
      const idlPath = path.join(__dirname, '../../../arcium-program/private_transfer/target/idl/private_transfer.json');

      if (!fs.existsSync(idlPath)) {
        console.warn('âš ï¸  IDL file not found:', idlPath);
        console.warn('âš ï¸  Arcium functions will be limited until program is built');
        return;
      }

      const arciumIdl = JSON.parse(fs.readFileSync(idlPath, 'utf-8'));

      // VÃ©rifier que l'IDL a la structure attendue
      if (!arciumIdl.instructions || !Array.isArray(arciumIdl.instructions)) {
        console.warn('âš ï¸  IDL format invalid - no instructions found');
        console.warn('âš ï¸  Arcium functions will work with limited features');
        return;
      }

      // Convertir l'IDL Arcium au format Anchor compatible
      const idl = this.convertArciumIdlToAnchor(arciumIdl);

      // CrÃ©er un wallet dummy pour le provider (sera remplacÃ© par le vrai wallet lors des appels)
      const dummyKeypair = Keypair.generate();
      const wallet = new Wallet(dummyKeypair);

      this.provider = new AnchorProvider(
        this.connection,
        wallet,
        { commitment: 'confirmed' }
      );

      // Debug: vÃ©rifier la structure de l'IDL
      console.log('ğŸ” IDL structure:', {
        hasVersion: !!idl.version,
        hasName: !!idl.name,
        instructionCount: idl.instructions?.length || 0,
        hasAddress: !!idl.metadata?.address
      });

      // âœ… SOLUTION: Utiliser 2 arguments seulement, comme dans les scripts Arcium officiels!
      // Anchor lit automatiquement le program_id depuis arciumIdl.address
      // Ne PAS passer PROGRAM_ID en 3Ã¨me argument, Ã§a cause l'erreur _bn
      console.log('ğŸ” Loading program from IDL.address:', arciumIdl.address);
      this.program = new Program(arciumIdl as any, this.provider);

      console.log('âœ… Arcium program loaded successfully');
      console.log('ğŸ“‹ Program ID:', this.program.programId.toString());
    } catch (error: any) {
      console.error('âŒ Failed to load Arcium program:', error.message);
      console.warn('âš ï¸  Arcium MPC features will be disabled. The program is deployed but IDL format may be incompatible.');
      console.warn('âš ï¸  You can still use basic wallet functions.');
    }
  }

  /**
   * RÃ©cupÃ¨re la clÃ© publique MXE pour le chiffrement
   */
  private async getMXEPublicKey(): Promise<Uint8Array> {
    if (this.mxePublicKey) {
      return this.mxePublicKey;
    }

    try {
      console.log('ğŸ”‘ Fetching MXE public key...');

      const mxeAccountInfo = await this.connection.getAccountInfo(MXE_ACCOUNT);
      if (!mxeAccountInfo) {
        throw new Error('MXE account not found');
      }

      // La clÃ© publique x25519 est stockÃ©e dans le compte MXE
      // Offset exact dÃ©pend du layout MXEAccount d'Arcium
      // GÃ©nÃ©ralement aprÃ¨s le discriminator (8 bytes)
      this.mxePublicKey = mxeAccountInfo.data.slice(8, 40);

      console.log('âœ… MXE public key retrieved');
      return this.mxePublicKey;
    } catch (error: any) {
      console.error('âŒ Failed to get MXE public key:', error);
      throw new Error(`Cannot retrieve MXE key: ${error.message}`);
    }
  }

  /**
   * Enregistre un nouvel utilisateur et lui assigne un ID unique
   * @param userKeypair - Keypair du wallet Arcium (doit signer)
   * @param payerKeypair - Server keypair (paie les frais)
   */
  async registerUser(userKeypair: Keypair, payerKeypair: Keypair): Promise<RegisterUserResult> {
    try {
      if (!this.program) {
        throw new Error('Program not loaded. Run: anchor build');
      }

      console.log('ğŸ“ Registering new user...');
      console.log('   Address:', userKeypair.publicKey.toString());

      // DÃ©river les PDAs
      const [userRegistryPDA] = PublicKey.findProgramAddressSync(
        [Buffer.from('user_registry')],
        PROGRAM_ID
      );

      // VÃ©rifier si le registre existe
      try {
        await this.program.account.userRegistry.fetch(userRegistryPDA);
      } catch (e) {
        console.log('âš ï¸  UserRegistry not initialized. Please run init-user-registry.ts first');
        throw new Error('UserRegistry not initialized');
      }

      const registry = await this.program.account.userRegistry.fetch(userRegistryPDA);
      const nextUserId = registry.nextUserId;

      const [balancePDA] = PublicKey.findProgramAddressSync(
        [Buffer.from('balance'), new BN(nextUserId).toArrayLike(Buffer, 'le', 4)],
        PROGRAM_ID
      );

      // VÃ©rifier si l'utilisateur est dÃ©jÃ  enregistrÃ©
      try {
        const existingBalance = await this.program.account.encryptedBalance.fetch(balancePDA);
        console.log('â„¹ï¸  User already registered with ID:', existingBalance.userId);
        return {
          success: true,
          userId: existingBalance.userId,
          balancePDA: balancePDA.toString(),
        };
      } catch (e) {
        // Utilisateur pas encore enregistrÃ©, on continue
      }

      // âœ… CrÃ©er un provider temporaire avec le payer keypair
      const tempWallet = new Wallet(userKeypair);
      const tempProvider = new AnchorProvider(
        this.connection,
        tempWallet,
        { commitment: 'confirmed' }
      );
      const tempProgram = new Program(this.program.idl, tempProvider);

      // Appeler l'instruction avec le bon programme
      // Note: 'user' = wallet Arcium (doit signer), 'payer' = server keypair (paie les frais)
      const tx = await tempProgram.methods
        .registerUser()
        .accounts({
          userRegistry: userRegistryPDA,
          balanceAccount: balancePDA,
          user: userKeypair.publicKey,  // L'utilisateur Arcium (SIGNE)
          payer: payerKeypair.publicKey,  // Server keypair qui paie
          systemProgram: SystemProgram.programId,
        })
        .signers([userKeypair])  // userKeypair doit signer (on l'a cÃ´tÃ© backend en mode custodial)
        .rpc();

      console.log('âœ… User registered successfully');
      console.log('   Transaction:', tx);
      console.log('   User ID:', nextUserId);
      console.log('   Balance PDA:', balancePDA.toString());

      return {
        success: true,
        userId: nextUserId,
        balancePDA: balancePDA.toString(),
        signature: tx,
      };
    } catch (error: any) {
      console.error('âŒ Failed to register user:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * RÃ©cupÃ¨re l'ID d'un utilisateur depuis son adresse
   */
  async getUserId(userAddress: PublicKey): Promise<number | null> {
    try {
      if (!this.program) {
        return null;
      }

      // Chercher dans tous les comptes balance pour trouver celui qui correspond Ã  l'adresse
      // Note: En production, on devrait avoir un mapping address -> user_id
      const [userRegistryPDA] = PublicKey.findProgramAddressSync(
        [Buffer.from('user_registry')],
        PROGRAM_ID
      );

      const registry = await this.program.account.userRegistry.fetch(userRegistryPDA);
      const maxUserId = registry.nextUserId;

      // Parcourir les IDs possibles (optimisation: utiliser un cache ou index)
      for (let userId = 0; userId < maxUserId; userId++) {
        const [balancePDA] = PublicKey.findProgramAddressSync(
          [Buffer.from('balance'), new BN(userId).toArrayLike(Buffer, 'le', 4)],
          PROGRAM_ID
        );

        try {
          const balance = await this.program.account.encryptedBalance.fetch(balancePDA);
          if (balance.ownerAddress.toString() === userAddress.toString()) {
            return userId;
          }
        } catch (e) {
          // Compte n'existe pas, continuer
        }
      }

      return null;
    } catch (error) {
      console.error('Error getting user ID:', error);
      return null;
    }
  }

  /**
   * RÃ©cupÃ¨re la balance chiffrÃ©e d'un utilisateur
   */
  async getEncryptedBalance(userId: number): Promise<BalanceInfo | null> {
    try {
      if (!this.program) {
        return null;
      }

      const [balancePDA] = PublicKey.findProgramAddressSync(
        [Buffer.from('balance'), new BN(userId).toArrayLike(Buffer, 'le', 4)],
        PROGRAM_ID
      );

      const balanceAccount = await this.program.account.encryptedBalance.fetch(balancePDA);

      return {
        userId: balanceAccount.userId,
        encryptedBalance: Array.from(balanceAccount.encryptedBalance),
        nonce: balanceAccount.nonce.toString(),
      };
    } catch (error) {
      console.error('Error fetching encrypted balance:', error);
      return null;
    }
  }

  /**
   * Effectue un transfert privÃ© entre deux utilisateurs
   */
  async executePrivateTransfer(
    senderId: number,
    receiverId: number,
    amount: bigint,
    senderKeypair: Keypair
  ): Promise<PrivateTransferResult> {
    try {
      if (!this.program) {
        throw new Error('Program not loaded. Run: anchor build');
      }

      console.log('\nğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.log('ğŸ” PRIVATE TRANSFER (ARCIUM MPC)');
      console.log('ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.log(`  Sender ID:    ${senderId}`);
      console.log(`  Receiver ID:  ${receiverId}`);
      console.log(`  Amount:       ${amount} lamports`);
      console.log('ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

      // 1. RÃ©cupÃ©rer les balances actuelles
      const senderBalance = await this.getEncryptedBalance(senderId);
      const receiverBalance = await this.getEncryptedBalance(receiverId);

      if (!senderBalance || !receiverBalance) {
        throw new Error('User balance not found');
      }

      // 2. Setup chiffrement
      const mxePublicKey = await this.getMXEPublicKey();
      const clientPrivateKey = x25519.utils.randomSecretKey();
      const clientPublicKey = x25519.getPublicKey(clientPrivateKey);
      const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
      const cipher = new RescueCipher(sharedSecret);
      const nonce = randomBytes(16);

      // 3. Chiffrer les donnÃ©es
      const senderIdEncrypted = cipher.encrypt([BigInt(senderId)], nonce);
      const receiverIdEncrypted = cipher.encrypt([BigInt(receiverId)], nonce);
      const amountEncrypted = cipher.encrypt([amount], nonce);

      console.log('ğŸ” Data encrypted for MPC computation...');

      // 4. DÃ©river les PDAs
      const [senderBalancePDA] = PublicKey.findProgramAddressSync(
        [Buffer.from('balance'), new BN(senderId).toArrayLike(Buffer, 'le', 4)],
        PROGRAM_ID
      );

      const [receiverBalancePDA] = PublicKey.findProgramAddressSync(
        [Buffer.from('balance'), new BN(receiverId).toArrayLike(Buffer, 'le', 4)],
        PROGRAM_ID
      );

      // 5. GÃ©nÃ©rer computation offset unique
      const computationOffset = new BN(Date.now());

      console.log('ğŸ“¡ Submitting transaction to Solana...');

      // 6. Envoyer la transaction
      const tx = await this.program.methods
        .privateTransfer(
          computationOffset,
          senderId,
          receiverId,
          Array.from(new Uint8Array(senderIdEncrypted[0].toBytesBE())),
          Array.from(new Uint8Array(receiverIdEncrypted[0].toBytesBE())),
          Array.from(new Uint8Array(amountEncrypted[0].toBytesBE())),
          Array.from(senderBalance.encryptedBalance),
          Array.from(receiverBalance.encryptedBalance),
          Array.from(clientPublicKey),
          new BN(Buffer.from(nonce))
        )
        .accounts({
          senderBalance: senderBalancePDA,
          receiverBalance: receiverBalancePDA,
          payer: senderKeypair.publicKey,
        })
        .signers([senderKeypair])
        .rpc();

      console.log('âœ… Transaction submitted:', tx);
      console.log('â³ Waiting for MPC computation (10-30 seconds)...');
      console.log('\nğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      console.log('âœ… PRIVATE TRANSFER QUEUED');
      console.log('ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

      return {
        success: true,
        signature: tx,
        computationOffset: computationOffset.toString(),
      };
    } catch (error: any) {
      console.error('âŒ Private transfer failed:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * DÃ©chiffre une balance (cÃ´tÃ© client)
   */
  async decryptBalance(
    encryptedBalance: Uint8Array,
    nonce: bigint,
    clientPrivateKey: Uint8Array
  ): Promise<bigint> {
    try {
      const mxePublicKey = await this.getMXEPublicKey();
      const sharedSecret = x25519.getSharedSecret(clientPrivateKey, mxePublicKey);
      const cipher = new RescueCipher(sharedSecret);

      const decrypted = cipher.decrypt([encryptedBalance], nonce);
      return decrypted[0];
    } catch (error: any) {
      console.error('Error decrypting balance:', error);
      throw error;
    }
  }

  /**
   * ExÃ©cute une transaction privÃ©e complÃ¨te depuis un utilisateur MongoDB
   *
   * Flow:
   * 1. RÃ©cupÃ¨re le wallet Solana de l'utilisateur depuis MongoDB
   * 2. CrÃ©e un wallet Arcium privÃ© si nÃ©cessaire
   * 3. Enregistre l'utilisateur dans Arcium
   * 4. Effectue le transfert privÃ© 100% masquÃ©
   *
   * @param mongoUserId - ID de l'utilisateur dans MongoDB
   * @param recipientAddress - Adresse publique du destinataire
   * @param amount - Montant en lamports
   */
  async executePrivateTransferFromUser(
    mongoUserId: string,
    recipientAddress: PublicKey,
    amount: bigint
  ): Promise<ExecutePrivateTransferFromUserResult> {
    try {
      console.log('ğŸ” Starting Arcium private transfer flow...');
      console.log(`   MongoDB User ID: ${mongoUserId}`);
      console.log(`   Recipient: ${recipientAddress.toString()}`);
      console.log(`   Amount: ${amount} lamports`);

      // Import dynamique pour Ã©viter les circular dependencies
      const { User } = await import('../../models/User.js');
      const { solanaWalletService } = await import('../wallet/solana-wallet.service.js');

      // 1. RÃ©cupÃ©rer l'utilisateur MongoDB
      const user = await User.findById(mongoUserId);
      if (!user) {
        return {
          success: false,
          error: 'User not found',
        };
      }

      if (!user.solanaWallet) {
        return {
          success: false,
          error: 'User does not have a Solana wallet',
        };
      }

      const senderPublicKey = new PublicKey(user.solanaWallet);
      console.log(`âœ… User wallet found: ${senderPublicKey.toString()}`);

      // 2. CrÃ©er wallet Arcium privÃ© si nÃ©cessaire (Privacy 1)
      let arciumWalletPubkey: PublicKey;

      if (!user.solanaPrivateWallet) {
        console.log('ğŸ”‘ Creating Arcium private wallet (Privacy 1)...');
        const arciumWalletPublicKey = await solanaWalletService.generatePrivateWallet(
          user._id.toString(),
          user.email
        );
        user.solanaPrivateWallet = arciumWalletPublicKey;
        await user.save();
        arciumWalletPubkey = new PublicKey(arciumWalletPublicKey);
        console.log(`âœ… Arcium wallet created: ${arciumWalletPublicKey}`);
      } else {
        arciumWalletPubkey = new PublicKey(user.solanaPrivateWallet);
        console.log(`âœ… Arcium wallet exists: ${user.solanaPrivateWallet}`);
      }

      // 3. Enregistrer dans Arcium si pas dÃ©jÃ  fait
      let arciumUserId: number;
      let balancePDA: string;

      if (user.arciumUserId === undefined || user.arciumUserId === null) {
        console.log('ğŸ“ Registering user in Arcium MPC system...');

        // RÃ©cupÃ©rer le keypair Arcium (custodial, stockÃ© backend)
        const arciumKeypair = await solanaWalletService.getPrivateWalletKeypair(user._id.toString());
        if (!arciumKeypair) {
          return {
            success: false,
            error: 'Arcium wallet keypair not found',
          };
        }

        // On utilise le server keypair pour payer les frais d'initialisation
        const serverKeypair = await solanaWalletService.getServerKeypair();
        if (!serverKeypair) {
          return {
            success: false,
            error: 'Server keypair not found',
          };
        }

        const registerResult = await this.registerUser(arciumKeypair, serverKeypair);

        if (!registerResult.success || registerResult.userId === undefined) {
          return {
            success: false,
            error: `Failed to register in Arcium: ${registerResult.error}`,
          };
        }

        arciumUserId = registerResult.userId;
        balancePDA = registerResult.balancePDA!;

        // Sauvegarder l'ID Arcium dans MongoDB
        user.arciumUserId = arciumUserId;
        await user.save();

        console.log(`âœ… User registered in Arcium with ID: ${arciumUserId}`);
      } else {
        arciumUserId = user.arciumUserId;

        // Calculer le balance PDA
        const [balancePDAKey] = PublicKey.findProgramAddressSync(
          [Buffer.from('balance'), new BN(arciumUserId).toArrayLike(Buffer, 'le', 4)],
          PROGRAM_ID
        );
        balancePDA = balancePDAKey.toString();

        console.log(`âœ… User already registered with Arcium ID: ${arciumUserId}`);
      }

      // 4. VÃ©rifier si le destinataire est dÃ©jÃ  enregistrÃ© dans Arcium, sinon l'enregistrer
      console.log('ğŸ” Checking if recipient is registered in Arcium...');
      let recipientArciumUserId = await this.getUserId(recipientAddress);

      if (recipientArciumUserId === null) {
        console.log('ğŸ“ Recipient not registered, registering now...');

        // Trouver le user MongoDB du recipient par son wallet Arcium
        const { User } = await import('../../models/User.js');
        const recipientUser = await User.findOne({ solanaPrivateWallet: recipientAddress.toString() });

        if (!recipientUser) {
          return {
            success: false,
            error: 'Recipient not found in system. Only registered users can receive private transfers.',
          };
        }

        // RÃ©cupÃ©rer le keypair Arcium du recipient
        const recipientKeypair = await solanaWalletService.getPrivateWalletKeypair(recipientUser._id.toString());
        if (!recipientKeypair) {
          return {
            success: false,
            error: 'Recipient Arcium keypair not found',
          };
        }

        // RÃ©cupÃ©rer le server keypair pour payer les frais
        const serverKeypair = await solanaWalletService.getServerKeypair();
        if (!serverKeypair) {
          return {
            success: false,
            error: 'Server keypair not found',
          };
        }

        const registerRecipientResult = await this.registerUser(recipientKeypair, serverKeypair);

        if (!registerRecipientResult.success || registerRecipientResult.userId === undefined) {
          return {
            success: false,
            error: `Failed to register recipient in Arcium: ${registerRecipientResult.error}`,
          };
        }

        recipientArciumUserId = registerRecipientResult.userId;
        console.log(`âœ… Recipient registered with Arcium ID: ${recipientArciumUserId}`);
      } else {
        console.log(`âœ… Recipient already registered with Arcium ID: ${recipientArciumUserId}`);
      }

      // 5. RÃ©cupÃ©rer le keypair du wallet Arcium de l'utilisateur
      console.log('ğŸ”‘ Loading user Arcium wallet keypair...');
      const arciumWalletKeypair = await solanaWalletService.getPrivateWalletKeypair(user._id.toString());

      if (!arciumWalletKeypair) {
        return {
          success: false,
          error: 'Failed to load Arcium wallet keypair',
        };
      }

      // 6. Effectuer le transfert privÃ© via MPC
      console.log('ğŸ” Executing private transfer via Arcium MPC...');
      console.log(`   Sender Arcium ID: ${arciumUserId} (ENCRYPTED IN MPC)`);
      console.log(`   Recipient Arcium ID: ${recipientArciumUserId} (ENCRYPTED IN MPC)`);
      console.log(`   Amount: ${amount} lamports (ENCRYPTED IN MPC)`);
      console.log(`   âš ï¸  On Solscan, you will see ONLY encrypted data!`);

      const transferResult = await this.executePrivateTransfer(
        arciumUserId,
        recipientArciumUserId,
        amount,
        arciumWalletKeypair
      );

      if (!transferResult.success) {
        return {
          success: false,
          error: `Private transfer failed: ${transferResult.error}`,
        };
      }

      console.log('âœ… Private transfer queued successfully!');
      console.log(`   Transaction: ${transferResult.signature}`);
      console.log(`   MPC computation in progress (10-30 seconds)...`);

      return {
        success: true,
        signature: transferResult.signature,
        senderWallet: arciumWalletPubkey.toString(),
        recipientWallet: recipientAddress.toString(),
        arciumUserId,
        arciumBalancePDA: balancePDA,
      };

    } catch (error: any) {
      console.error('âŒ Error in executePrivateTransferFromUser:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }
}

const privateTransferService = new PrivateTransferService();
export default privateTransferService;
