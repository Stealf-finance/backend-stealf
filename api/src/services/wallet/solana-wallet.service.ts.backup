import { Keypair } from '@solana/web3.js';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Fix for __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Service de gestion des wallets Solana
 * G√©n√®re et stocke de mani√®re s√©curis√©e les wallets pour chaque utilisateur
 */
class SolanaWalletService {
  private walletDir: string;
  private encryptionKey: Buffer;

  constructor() {
    // Dossier de stockage des wallets (√† c√¥t√© de .keys/)
    this.walletDir = path.join(__dirname, '../../../.wallets');

    // Cr√©er le dossier s'il n'existe pas
    if (!fs.existsSync(this.walletDir)) {
      fs.mkdirSync(this.walletDir, { recursive: true, mode: 0o700 });
      console.log('üìÅ Wallet directory created:', this.walletDir);
    }

    // R√©cup√©rer ou cr√©er la cl√© de chiffrement
    this.encryptionKey = this.getOrCreateEncryptionKey();
  }

  /**
   * R√©cup√®re ou cr√©e la cl√© de chiffrement AES-256
   */
  private getOrCreateEncryptionKey(): Buffer {
    const keyPath = path.join(__dirname, '../../../.keys/wallet-encryption.key');

    if (fs.existsSync(keyPath)) {
      return fs.readFileSync(keyPath);
    }

    // G√©n√©rer une nouvelle cl√© AES-256 (32 bytes)
    const key = crypto.randomBytes(32);

    // Cr√©er le dossier .keys s'il n'existe pas
    const keysDir = path.dirname(keyPath);
    if (!fs.existsSync(keysDir)) {
      fs.mkdirSync(keysDir, { recursive: true, mode: 0o700 });
    }

    // Sauvegarder avec permissions restrictives
    fs.writeFileSync(keyPath, key, { mode: 0o600 });
    console.log('üîë Wallet encryption key created:', keyPath);

    return key;
  }

  /**
   * Chiffre une cl√© priv√©e avec AES-256-GCM
   */
  private encrypt(secretKey: Uint8Array): string {
    const iv = crypto.randomBytes(16); // IV de 16 bytes
    const cipher = crypto.createCipheriv('aes-256-gcm', this.encryptionKey, iv);

    const encrypted = Buffer.concat([
      cipher.update(Buffer.from(secretKey)),
      cipher.final()
    ]);

    const authTag = cipher.getAuthTag();

    // Format: iv:authTag:encrypted (en base64)
    return `${iv.toString('base64')}:${authTag.toString('base64')}:${encrypted.toString('base64')}`;
  }

  /**
   * D√©chiffre une cl√© priv√©e
   */
  private decrypt(encryptedData: string): Uint8Array {
    const [ivB64, authTagB64, encryptedB64] = encryptedData.split(':');

    const iv = Buffer.from(ivB64, 'base64');
    const authTag = Buffer.from(authTagB64, 'base64');
    const encrypted = Buffer.from(encryptedB64, 'base64');

    const decipher = crypto.createDecipheriv('aes-256-gcm', this.encryptionKey, iv);
    decipher.setAuthTag(authTag);

    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);

    return new Uint8Array(decrypted);
  }

  /**
   * G√©n√®re un nouveau wallet Solana pour un utilisateur
   * @param userId - ID MongoDB de l'utilisateur
   * @param email - Email de l'utilisateur (pour logging)
   * @returns Adresse publique du wallet g√©n√©r√©
   */
  async generateWallet(userId: string, email: string): Promise<string> {
    try {
      console.log(`üîë Generating Solana wallet for user: ${email} (${userId})`);

      // G√©n√©rer une nouvelle paire de cl√©s Solana
      const keypair = Keypair.generate();
      const publicKey = keypair.publicKey.toBase58();
      const secretKey = keypair.secretKey;

      console.log(`‚úÖ Wallet generated: ${publicKey}`);

      // Chiffrer la cl√© priv√©e
      const encryptedSecretKey = this.encrypt(secretKey);

      // Sauvegarder dans un fichier JSON
      const walletData = {
        userId,
        email,
        publicKey,
        encryptedSecretKey,
        createdAt: new Date().toISOString()
      };

      const walletFilePath = path.join(this.walletDir, `${userId}.json`);
      fs.writeFileSync(
        walletFilePath,
        JSON.stringify(walletData, null, 2),
        { mode: 0o600 } // Permissions restrictives
      );

      console.log(`üíæ Wallet saved: ${walletFilePath}`);
      console.log(`üìç Public key: ${publicKey}`);

      return publicKey;
    } catch (error) {
      console.error('‚ùå Error generating wallet:', error);
      throw new Error('Failed to generate Solana wallet');
    }
  }

  /**
   * R√©cup√®re le wallet d'un utilisateur
   * @param userId - ID MongoDB de l'utilisateur
   * @returns Keypair Solana d√©chiffr√©
   */
  async getWallet(userId: string): Promise<Keypair | null> {
    try {
      const walletFilePath = path.join(this.walletDir, `${userId}.json`);

      if (!fs.existsSync(walletFilePath)) {
        console.log(`‚ö†Ô∏è Wallet not found for user: ${userId}`);
        return null;
      }

      const walletData = JSON.parse(fs.readFileSync(walletFilePath, 'utf8'));
      const secretKey = this.decrypt(walletData.encryptedSecretKey);

      return Keypair.fromSecretKey(secretKey);
    } catch (error) {
      console.error('‚ùå Error retrieving wallet:', error);
      throw new Error('Failed to retrieve Solana wallet');
    }
  }

  /**
   * R√©cup√®re l'adresse publique d'un wallet
   * @param userId - ID MongoDB de l'utilisateur
   * @returns Adresse publique du wallet
   */
  async getPublicKey(userId: string): Promise<string | null> {
    try {
      const walletFilePath = path.join(this.walletDir, `${userId}.json`);

      if (!fs.existsSync(walletFilePath)) {
        return null;
      }

      const walletData = JSON.parse(fs.readFileSync(walletFilePath, 'utf8'));
      return walletData.publicKey;
    } catch (error) {
      console.error('‚ùå Error retrieving public key:', error);
      return null;
    }
  }

  /**
   * V√©rifie si un utilisateur a d√©j√† un wallet
   * @param userId - ID MongoDB de l'utilisateur
   */
  async hasWallet(userId: string): Promise<boolean> {
    const walletFilePath = path.join(this.walletDir, `${userId}.json`);
    return fs.existsSync(walletFilePath);
  }

  /**
   * G√©n√®re un wallet priv√© (Privacy 1) pour un utilisateur
   * @param userId - ID MongoDB de l'utilisateur
   * @param email - Email de l'utilisateur (pour logging)
   * @returns Adresse publique du wallet priv√© g√©n√©r√©
   */
  async generatePrivateWallet(userId: string, email: string): Promise<string> {
    try {
      console.log(`üîê Generating private Solana wallet for user: ${email} (${userId})`);

      // G√©n√©rer une nouvelle paire de cl√©s Solana pour le wallet priv√©
      const keypair = Keypair.generate();
      const publicKey = keypair.publicKey.toBase58();
      const secretKey = keypair.secretKey;

      console.log(`‚úÖ Private wallet generated: ${publicKey}`);

      // Chiffrer la cl√© priv√©e
      const encryptedSecretKey = this.encrypt(secretKey);

      // Sauvegarder dans un fichier JSON s√©par√© (avec suffix -private)
      const walletData = {
        userId,
        email,
        publicKey,
        encryptedSecretKey,
        type: 'private', // Privacy 1 wallet
        createdAt: new Date().toISOString()
      };

      const walletFilePath = path.join(this.walletDir, `${userId}-private.json`);
      fs.writeFileSync(
        walletFilePath,
        JSON.stringify(walletData, null, 2),
        { mode: 0o600 } // Permissions restrictives
      );

      console.log(`üíæ Private wallet saved: ${walletFilePath}`);
      console.log(`üìç Private wallet public key: ${publicKey}`);

      return publicKey;
    } catch (error) {
      console.error('‚ùå Error generating private wallet:', error);
      throw new Error('Failed to generate private Solana wallet');
    }
  }

  /**
   * R√©cup√®re le wallet priv√© d'un utilisateur
   * @param userId - ID MongoDB de l'utilisateur
   * @returns Keypair Solana d√©chiffr√© du wallet priv√©
   */
  async getPrivateWallet(userId: string): Promise<Keypair | null> {
    try {
      const walletFilePath = path.join(this.walletDir, `${userId}-private.json`);

      if (!fs.existsSync(walletFilePath)) {
        console.log(`‚ö†Ô∏è Private wallet not found for user: ${userId}`);
        return null;
      }

      const walletData = JSON.parse(fs.readFileSync(walletFilePath, 'utf8'));
      const secretKey = this.decrypt(walletData.encryptedSecretKey);

      return Keypair.fromSecretKey(secretKey);
    } catch (error) {
      console.error('‚ùå Error retrieving private wallet:', error);
      throw new Error('Failed to retrieve private Solana wallet');
    }
  }

  /**
   * R√©cup√®re l'adresse publique du wallet priv√©
   * @param userId - ID MongoDB de l'utilisateur
   * @returns Adresse publique du wallet priv√©
   */
  async getPrivatePublicKey(userId: string): Promise<string | null> {
    try {
      const walletFilePath = path.join(this.walletDir, `${userId}-private.json`);

      if (!fs.existsSync(walletFilePath)) {
        return null;
      }

      const walletData = JSON.parse(fs.readFileSync(walletFilePath, 'utf8'));
      return walletData.publicKey;
    } catch (error) {
      console.error('‚ùå Error retrieving private wallet public key:', error);
      return null;
    }
  }
}

// Export singleton
export const solanaWalletService = new SolanaWalletService();
